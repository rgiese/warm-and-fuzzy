namespace Flatbuffers.Firmware;

// Any breaking changes to this file should also rev the envelope magic signature in
// - //packages/api/src/shared/firmware/thermostatConfigurationAdapter.ts
// - //packages/firmware/thermostat/Main.cpp

enum ThermostatAction : ubyte (bit_flags) { Heat, Cool, Circulate }

///
/// Temperatures are stored multiplied by 100, e.g. a temperature of 16.5 is stored as a 165.
/// Given that we're really just dealing with a range of 0-100, a multiplied-out range of 0-10000 fits just fine into a uint16.
///

enum ThermostatSettingType : ubyte { Undefined, Hold, Scheduled }

enum DaysOfWeek : ubyte (bit_flags) { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday }

struct ThermostatSetting {
  ///
  /// We won't bother making a formal union out of this since that'll just end up taking more space
  /// than what we could hope to save.
  ///
  
  set_point_heat_x100: uint16;
  set_point_cool_x100: uint16;
  set_point_circulate_above_x100: uint16;
  set_point_circulate_below_x100: uint16;
  allowed_actions: ThermostatAction;

  type: ThermostatSettingType;

  _padding0: uint16;

  /// For Hold settings
  /// hold_until: seconds since UTC epoch
  hold_until: uint32;

  /// For Scheduled settings
  days_of_week: DaysOfWeek;
  _padding1: uint8;
  at_minutes_since_midnight: uint16;
}


///
/// Defaults are provided so the firmware can reset itself if state got corrupted.
///
table ThermostatConfiguration {
  external_sensor_id: uint64;

  threshold_x100: uint16 = 50; // 0.5 C
  cadence: uint16 = 600; // 10 minutes

  /// {current,next}_timezone_utc_offset: signed IANA UTC offset, e.g. PST = 480
  current_timezone_utc_offset: int16;
  next_timezone_utc_offset: int16;

  /// next_timezone_change: seconds since UTC epoch when next_timezone_utc_offset becomes applicable
  next_timezone_change: uint32;

  thermostat_settings: [ThermostatSetting];
}

file_identifier "WAF3";
root_type ThermostatConfiguration;